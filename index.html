<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metrics Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>

</head>
<body>
<div>
    <label>Select Benchmark:</label>
    <label for="benchmarkSelector"></label><select id="benchmarkSelector"></select>
</div>
<div>
    <label>Select Metric:</label>
    <label for="metricSelector"></label><select id="metricSelector"></select>
</div>
<div>
    <label for="lowerBound">Lower Bound:</label>
    <input type="number" id="lowerBound" placeholder="Enter lower bound">
    <label for="upperBound">Upper Bound:</label>
    <input type="number" id="upperBound" placeholder="Enter upper bound">
    <button id="updateBounds">Update Bounds</button>
</div>

<canvas id="myChart"></canvas>

<script>
    let myChart = null;
    const ctx = document.getElementById('myChart').getContext('2d');
    const benchmarkSelector = document.getElementById('benchmarkSelector');
    const metricSelector = document.getElementById('metricSelector');
    let data;

    benchmarkSelector.addEventListener('change', populateMetrics);
    metricSelector.addEventListener('change', updateChart);

    async function fetchData() {
        const response = await fetch('data.json');
        data = await response.json();
        if (data) {
            console.log("Data loaded successfully");
        }
        populateBenchmarks();
    }

    function populateBenchmarks() {
        for (const benchmark in data.entries) {
            console.log("Populating benchmark")
            const option = document.createElement('option');
            option.value = benchmark;
            option.textContent = benchmark;
            benchmarkSelector.appendChild(option);
        }
        populateMetrics();
    }

    function populateMetrics() {
        metricSelector.innerHTML = '';
        const selectedBenchmark = benchmarkSelector.value;

        const allMetrics = new Set();
        data.entries[selectedBenchmark].forEach(entry => {
            entry.metrics.forEach(metric => {
                allMetrics.add(metric.name);
            });
        });

        allMetrics.forEach(metricName => {
            const option = document.createElement('option');
            option.value = metricName;
            option.textContent = metricName;
            metricSelector.appendChild(option);
        });

        updateChart();
    }

    function getEvaluationResults(benchmark, metric) {
        return data.entries[benchmark].map(entry => {
            if (entry.evaluation && entry.evaluation.evaluationResult
            && entry.evaluation.evaluationParams) {
                console.log("Entr.evaluation", entry.evaluation)
                console.log("Entr.evaluation.evaluationParams", entry.evaluation.evaluationParams)
                const metricIndex = entry.evaluation.evaluationParams.metricNames.indexOf(metric);
                return entry.evaluation.evaluationResult.result[metricIndex];
            }
            return null;
        });
    }

    function extractData(benchmark, metric) {
        const dates = [];
        const values = [];

        for (let entry of data.entries[benchmark]) {
            dates.push(moment(entry.date).format('YYYY-MM-DD HH:mm'));
            const metricObj = entry.metrics.find(m => m.name === metric);
            if (metricObj) {
                values.push(metricObj.value);
            }
        }

        return { dates, values };
    }

    function updateChart() {
        const selectedBenchmark = benchmarkSelector.value;
        const selectedMetric = metricSelector.value;

        const dates = [];
        const values = [];
        let unit = "";

        const evaluationResults = getEvaluationResults(selectedBenchmark, selectedMetric);
        for (let entry of data.entries[selectedBenchmark]) {
            if (!unit) {
                const metricObj = entry.metrics.find(m => m.name === selectedMetric);
                if (metricObj) {
                    unit = metricObj.unit;
                }
            }

            dates.push(moment(entry.date).format('YYYY-MM-DD HH:mm'));
            const metricValue = entry.metrics.find(m => m.name === selectedMetric)?.value;
            values.push(metricValue ?? null);
        }

        // Assuming lowerBound and upperBound are retrieved from somewhere, set them to some defaults for now
        let lowerBound = 300; // These values should come from user input
        let upperBound = 400; // These values should come from user input

        // Add two new datasets to your chart data for the bounds
        const boundDatasets = [
            {
                label: 'Lower Bound',
                data: Array(dates.length).fill(lowerBound), // Creates an array with the same length as `dates`, all values are `lowerBound`
                borderColor: 'blue',
                borderWidth: 2,
                pointRadius: 0, // No points for this line
                fill: false,
            },
            {
                label: 'Upper Bound',
                data: Array(dates.length).fill(upperBound), // Creates an array with the same length as `dates`, all values are `upperBound`
                borderColor: 'red',
                borderWidth: 2,
                pointRadius: 0, // No points for this line
                fill: '-1', // Fills the area between this line and the previous dataset (lower bound)
            }
        ];

        // Add the bound datasets to your existing datasets


        if (myChart) {
            myChart.destroy();
        }

        myChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: dates,
                datasets: [
                    {
                        label: selectedMetric,
                        data: values,
                        pointBackgroundColor: evaluationResults.map(result => result === "passed" ? "green" : "red"),
                        pointRadius: evaluationResults.map(result => result ? 6 : 3),
                        borderColor: 'green',
                        fill: false,
                    }
                ]
            },
            options: {
                layout: {
                    padding: {
                        left: 60,
                        right: 10,
                        top: 10,
                        bottom: 10
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Time'
                        },
                        ticks: {
                            autoSkip: true,
                            maxRotation: 75,
                            minRotation: 75,
                            color: '#555555'
                        },
                        grid: {
                            drawBorder: false,
                            color: '#D6D6D6'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: unit
                        },
                        ticks: {
                            color: '#555555'
                        },
                        grid: {
                            drawBorder: false,
                            color: '#D6D6D6'
                        }
                    }
                },
                elements: {
                    line: {
                        tension: 0,
                        borderColor: '#2C3E50',
                        borderWidth: 2
                    },
                    point: {
                        backgroundColor: '#E74C3C'
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            afterTitle: items => {
                                const index = items[0].dataIndex;
                                const dataEntry = data.entries[selectedBenchmark][index];
                                return '\n Commit message: ' + dataEntry.commit.message +
                                    '\n Commit time: ' + dataEntry.commit.timestamp +
                                    ' \n Committed by: ' + dataEntry.commit.committer.username + '\n';
                            },
                            label: item => {
                                const dataEntry = data.entries[selectedBenchmark][item.dataIndex];
                                const info = dataEntry.otherInfo;
                                return 'Benchmark information: ' + info;
                            },
                            afterLabel: item => {
                                const dataEntry = data.entries[selectedBenchmark][item.dataIndex];
                                const evalParams = dataEntry.evaluation ? dataEntry.evaluation.evaluationParams : null;

                                var tooltipString = "Parameters: \n" +
                                    Object.keys(dataEntry.parametrization).map(key => `${key}: ${dataEntry.parametrization[key]}`).join('\n');

                                if (evalParams) {
                                    const metricIndex = evalParams.metricNames.indexOf(selectedMetric);
                                    const currentVal = evalParams.is[metricIndex];
                                    const shouldBe = evalParams.shouldBe[metricIndex];
                                    const referenceVal = evalParams.than[metricIndex];

                                    tooltipString += "\n\nEvaluation:\n" +
                                        "Method: " + evalParams.evaluationMethod + "\n" +
                                        "Current Value: " + currentVal + "\n" +
                                        "Should Be: " + shouldBe + "\n" +
                                        "Reference Value: " + referenceVal;
                                }
                                return tooltipString;
                            }                        }
                    },
                    legend: {
                        display: false,
                        labels: {
                            color: '#555555'
                        }
                    }

                }
            }

        });
        myChart.data.datasets.push(...boundDatasets);
    }


    fetchData();

    document.getElementById('updateBounds').addEventListener('click', () => {
        // Retrieve the bound values from the input fields
        lowerBound = parseFloat(document.getElementById('lowerBound').value);
        upperBound = parseFloat(document.getElementById('upperBound').value);

        // Call updateChart to redraw the chart with the new bounds
        updateChart();
    });

</script>
</body>
</html>
